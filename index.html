<!DOCTYPE html><html lang="en"><head><title>Notes as I Go</title><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Sans+Pro:300|Lora"><link rel="stylesheet" href="css/styles.css"></head><body><header><h1>Lawrence's Guide to Crushing Google</h1><nav><ul><li><a href="index.html">Data Structures and Algorithms</a></li><li><a href="web.html">Web Development</a></li></ul></nav></header><div class="anchors"><h3>Jump to section:</h3><a href="#algorithm-approaches">Algorithm Approaches</a><br><a href="#trees-and-graphs">Trees and Graphs</a></div><div class="more-info"><p>This was my attempt to keep me obligated to studying
and learning new things - i.e. using Jade for the first 
time. More available on github. Check me out dudes! </p><a href="http://www.github.com/lawhump">My Github</a></div><section class="content"><article id="algorithm-approaches"><h2>Algorithm Approaches</h2><h3><strong>Five Algorithm Approaches</strong></h3><ol><li><h4>Examplify</h4><p>Write out specific examples of the problem, 
and see if you can figure out a general rule.
</p></li><li><h4>Pattern Matching</h4><p>Consider what problems the algorithm is similar
to and figure out how to modify it to make it work.
</p><em>I should probably use this more often</em></li><li>       <h4>Simplify and Generalize</h4><p>Change a constraint (data type, size, etc.) to 
simplify the problem. Then (try to) solve it.
Then generalize and solve it.</p></li><li>       <h4>Base Case and Build</h4><p>Solve for one case. Then two. Then n.
Naturally recursive.</p></li><li>       <h4>Data Structure Brainstorm</h4><p>"Hacky". Go through a list of data structures 
and see which one(s) applies/apply.

</p></li></ol></article><article id="trees-and-graphs"><h2>Trees and Graphs</h2><h3><strong>Potential Issues to Watch Out For</strong></h3><h5>Binary Tree vs. Binary Search Tree<p>Don't jump to conclusions. Remember to ask the 
interviewer to clarify.
</p></h5><h5>Balanced vs. Unbalanced<p>Ask interviewer to clarify. Usually balanced within 
a certain tolerance.
</p></h5><h5>Full and Complete<p>Again, ask to clarify. Full - 0 or n children, where
n is 
</p></h5><h3><strong>Three Ways to Represent Graphs in Memory</strong></h3><ol><li>Nodes as objects and edges as pointers</li><li>Adjacency Matrix</li><li>Adjacency List</li></ol></article></section><footer><h6>Lawrence Humphrey &#169; 2015</h6></footer></body></html>