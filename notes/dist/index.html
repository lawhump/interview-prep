<!DOCTYPE html><html lang="en"><head><title>Notes as I Go</title><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Sans+Pro:300|Lora"><link rel="stylesheet" href="css/styles.css"></head><body><header><h1>Lawrence's Guide to Crushing Google</h1></header><div class="anchors"><h3>Jump to section:</h3><a href="#algorithm-approaches">Algorithm Approaches</a><br><a href="#trees-and-graphs">Trees and Graphs</a></div><div class="more-info"><p>This was my attempt to keep me obligated to studying
and learning new things â€” i.e. using Jade for the first 
time. More available on github. Check me out dudes! </p><a href="http://www.github.com/lawhump">My Github</a></div><section class="content"><article id="algorithm-approaches"><h2>Algorithm Approaches</h2><h3><strong>Five Algorithm Approaches</strong></h3><ol><li><h4>Examplify</h4><p>Write out specific examples of the problem, 
and see if you can figure out a general rule.
</p></li><li><h4>Pattern Matching</h4><p>Consider what problems the algorithm is similar
to and figure out how to modify it to make it work.
</p><em>I should probably use this more often</em></li><li>       <h4>Simplify and Generalize</h4><p>Change a constraint (data type, size, etc.) to 
simplify the problem. Then (try to) solve it.
Then generalize and solve it.</p></li><li>       <h4>Base Case and Build</h4><p>Solve for one case. Then two. Then n.
Naturally recursive.</p></li><li>       <h4>Data Structure Brainstorm</h4><p>"Hacky". Go through a list of data structures 
and see which one(s) applies/apply.

</p></li></ol></article><article id="trees-and-graphs"><h2>Trees and Graphs</h2><h3><strong>Potential Issues to Watch Out For</strong></h3><h4>Binary Tree vs. Binary Search Tree</h4><h4>Balanced vs. Unbalanced</h4><h4>Full and Complete</h4><h3>Three Ways to Represent Graphs in Memory</h3><ol><li>Nodes as objects and edges as pointers</li><li>Adjacency Matrix</li><li>Adjacency List</li></ol></article></section></body></html>