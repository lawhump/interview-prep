<!DOCTYPE html><html lang="en"><head><title>Notes as I Go</title><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Sans+Pro:300|Lora"><link rel="stylesheet" href="css/styles.css"></head><body><header><h1>Lawrence's Guide to Crushing Google</h1><nav><ul><li><a href="index.html">Data Structures and Algorithms</a></li><li><a href="web.html">Web Development</a></li></ul></nav></header><aside class="anchors"><h3>Jump to section:</h3><a href="#algorithm-approaches">Algorithm Approaches</a><br><a href="#trees">Trees</a><br><a href="#graphs">Graphs</a></aside><aside class="more-info"><p>This was my attempt to keep me obligated to study
and learn new things - i.e. using Jade for the first 
time. Implementation and more available on github. 
Check me out dudes! </p><a href="http://www.github.com/lawhump">My Github</a></aside><section class="content"><article id="algorithm-approaches"><h2>Algorithm Approaches</h2><h3><strong>Five Algorithm Approaches</strong></h3><ol><li><h4>Examplify</h4><p>Write out specific examples of the problem, 
and see if you can figure out a general rule.
</p></li><li><h4>Pattern Matching</h4><p>Consider what problems the algorithm is similar
to and figure out how to modify it to make it work.
</p><em>I should probably use this more often</em></li><li>       <h4>Simplify and Generalize</h4><p>Change a constraint (data type, size, etc.) to 
simplify the problem. Then (try to) solve it.
Then generalize and solve it.</p></li><li>       <h4>Base Case and Build</h4><p>Solve for one case. Then two. Then n.
Naturally recursive.</p></li><li>       <h4>Data Structure Brainstorm</h4><p>"Hacky". Go through a list of data structures 
and see which one(s) applies/apply.

</p></li></ol></article><article id="trees"><h2>Trees</h2><h3><strong>Potential Issues to Watch Out For</strong></h3><h4>Binary Tree vs. Binary Search Tree</h4><p>Don't jump to conclusions. Remember to ask the 
interviewer to clarify.</p><h4>Balanced vs. Unbalanced</h4><p>Ask interviewer to clarify. Usually balanced within 
a certain tolerance.</p><h4>Full and Complete</h4><p>Again, ask to clarify. Full - 0 or n children, where
n is derived from the n-ary tree.</p><h3><strong>Common Types</strong></h3><h4>Binary Trees</h4><p>Tree structure categorized by having at most two children, commonly referred to as
left and right. Other terms often associated with binary trees are<em>full, complete, balanced, and perfect.</em><br>Link: <a href="https://en.wikipedia.org/wiki/Binary_tree">https://en.wikipedia.org/wiki/Binary_tree</a></p><h4>Binary Search Trees</h4><p>A subset of binary trees, where for all nodes left of <em>root, </em><em>left.val &lt; root.val. </em>Similarly, for all nodes right of <em>root, </em><em>root.val &lt; right.val.</em><br><a href="https://en.wikipedia.org/wiki/Binary_search_tree">https://en.wikipedia.org/wiki/Binary_search_tree</a></p><h4>AVL Trees</h4><p>A self-balancing binary search tree. This leads to better worst case performance for typical BST functions
such as <em>insert, find, </em>and <em>remove.</em><br><a href="https://en.wikipedia.org/wiki/AVL_tree">https://en.wikipedia.org/wiki/AVL_tree</a></p><h4>B Trees</h4><p>Yo dude</p><h4>n-ary Trees</h4><p>A tree that for any node, it can have at most n children. Binary trees are a special case of n-ary trees
where n=2. <a href="https://en.wikipedia.org/wiki/K-ary_tree">https://en.wikipedia.org/wiki/K-ary_tree</a></p><h4>Trie Trees</h4><p>Also called a <em>prefix-tree </em>or <em>radix-tree, </em>According to Wikipedia: <p class="blockquote"> 
"All the descendants of a node have a common prefix of the string associated with that node, and the 
root is associated with the empty string. Values are normally not associated with every node, only with 
leaves and some inner nodes that correspond to keys of interest.<br>Though tries are most commonly keyed by character strings, they don't need to be. The same algorithms 
can easily be adapted to serve similar functions of ordered lists of any construct, e.g., permutations 
on a list of digits or shapes. In particular, a bitwise trie is keyed on the individual bits making up 
a short, fixed size of bits such as an integer number or memory address."</p><br>They are sometimes used as a replacement to hashtables. <a href="http://stackoverflow.com/questions/245878/how-do-i-choose-between-a-hash-table-and-a-trie-prefix-tree">This StackOverflow thread </a>does a great job weighing why you'd use one over the other. In summary (because I know no one likes clicking 
on links), it says, verbatim:<aside class="blockquote"><p>"Advantages of tries:
The basics:<ul><li>Predictable O(k) lookup time where k is the size of the key</li><li>Lookup can take less than k time if it's not there</li><li>Supports ordered traversal</li><li>No need for a hash function</li><li>Deletion is straightforward</li></ul>New operations:<ul><li>You can quickly look up prefixes of keys, enumerate all entries with a given prefix, etc.</li></ul>Advantages of linked structure:<ul><li>If there are many common prefixes, the space they require is shared.</li><li>Immutable tries can share structure. Instead of updating a trie in place, you can build a new one that's different only along one branch, elsewhere pointing into the old trie. This can be useful for concurrency, multiple simultaneous versions of a table, etc.</li><li>An immutable trie is compressible. That is, it can share structure on the suffixes as well, by hash-consing.</li></ul>Advantages of hashtables:<ul> <li>Everyone knows hashtables, right? Your system will already have a nice well-optimized implementation, faster than tries for most purposes.</li><li>Your keys need not have any special structure.</li><li>More space-efficient than the obvious linked trie structure"</li></ul></p></aside><a href="https://en.wikipedia.org/wiki/Trie">https://en.wikipedia.org/wiki/Trie</a></p><h4>k-d Trees</h4><p>A multi-dimensional binary search tree. Very trippy stuff man. Nearest neighbor is a common thing on this tree.<br><a href="https://en.wikipedia.org/wiki/K-d_tree">https://en.wikipedia.org/wiki/K-d_tree</a></p></article><article id="graphs"><h2>Graphs</h2><h3><strong>Three Ways to Represent Graphs in Memory</strong></h3><ol><li>Nodes as objects and edges as pointers - very readable and conceptually intuitive</li><li>Adjacency Matrix - best used if the graph is dense, as resizing is costly</li><li>Adjacency List - best used if the graph is sparse</li></ol></article></section><footer><h6>Lawrence Humphrey &#169; 2015</h6></footer></body></html>